//! Macros for quickly writing consumers.
//!
//! More specifically, a family of macros for wrapper consumers with an invariant wrapper and implementing various traits on the
//! resulting type by forwarding to the wrapper.
//!
//! Also, a family of macros to implement `local_nb::Consumer` by referring to an implementation of `sync::local_nb::Consumer`.
//!
//! See `common::consumer::into_slice` for example usage of all these macros.

// Macro syntax for handling generic parameters from https://stackoverflow.com/a/61189128

/// Create an opaque type of name `outer` that wraps the consumer `inner` with invariant checks.
macro_rules! invarianted_consumer_outer_type {
    ($(#[$doc:meta])* $outer:ident $inner:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? ) => {
        $(#[$doc])*
        pub struct $outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?(crate::common::consumer::Invariant<$inner $(< $( $lt ),+ >)?>);
    }
}

/// Implement `Debug` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_debug {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? ) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            core::fmt::Debug
        for $outer
            $(< $( $lt ),+ >)?
        {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.0.fmt(f)
            }
        }
    }
}

/// Implement `AsRef` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_as_ref {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?; $t:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            core::convert::AsRef<$t>
        for $outer
            $(< $( $lt ),+ >)?
        {
            fn as_ref(&self) -> &$t {
                self.0.as_ref().as_ref()
            }
        }
    }
}

/// Implement `AsMut` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_as_mut {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?; $t:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            core::convert::AsMut<$t>
        for $outer
            $(< $( $lt ),+ >)?
        {
            fn as_mut(&mut self) -> &mut $t {
                self.0.as_mut().as_mut()
            }
        }
    }
}

/// Implement `Wrapper` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_wrapper {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?; $t:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            wrapper::Wrapper<$t>
        for $outer
            $(< $( $lt ),+ >)?
        {
            fn into_inner(self) -> $t {
                self.0.into_inner().into_inner()
            }
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::Consumer`.
macro_rules! invarianted_consumer_methods {
    () => {
        fn consume(&mut self, item: Self::Item) -> Result<(), Self::Error> {
            Consumer::consume(&mut self.0, item)
        }

        fn close(&mut self, fin: Self::Final) -> Result<(), Self::Error> {
            Consumer::close(&mut self.0, fin)
        }

        fn consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::sync::ConsumeFullSliceError<Self::Error>>
            where Self::Item: Clone
        {
            Consumer::consume_full_slice(&mut self.0, buf)
        }
    }
}

/// Implement `sync::Consumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_consumer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::sync::Consumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            $(#[$doc_item])*
            type Item = $t_item;
            $(#[$doc_final])*
            type Final = $t_final;
            $(#[$doc_error])*
            type Error = $t_error;

            invarianted_consumer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::BufferedConsmer`.
macro_rules! invarianted_buffered_consumer_methods {
    () => {
        fn flush(&mut self) -> Result<(), Self::Error> {
            BufferedConsumer::flush(&mut self.0)
        }
    }
}

/// Implement `sync::BufferedConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_buffered_consumer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::sync::BufferedConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_buffered_consumer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::BulkConsumer`.
macro_rules! invarianted_bulk_consumer_methods {
    () => {
        fn expose_slots(&mut self) -> Result<&mut [MaybeUninit<Self::Item>], Self::Error> {
            BulkConsumer::expose_slots(&mut self.0)
        }

        unsafe fn consume_slots(&mut self, amount: usize) -> Result<(), Self::Error> {
            BulkConsumer::consume_slots(&mut self.0, amount)
        }

        fn bulk_consume(&mut self, buf: &[Self::Item]) -> Result<usize, Self::Error> {
            BulkConsumer::bulk_consume(&mut self.0, buf)
        }

        fn bulk_consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::sync::ConsumeFullSliceError<Self::Error>> {
            BulkConsumer::bulk_consume_full_slice(&mut self.0, buf)
        }
    }
}

/// Implement `sync::BulkConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_bulk_consumer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::sync::BulkConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_bulk_consumer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::Consumer`.
macro_rules! invarianted_consumer_methods_local_nb {
    () => {
        async fn consume(&mut self, item: Self::Item) -> Result<(), Self::Error> {
            ConsumerLocalNb::consume(&mut self.0, item).await
        }

        async fn close(&mut self, f: Self::Final) -> Result<(), Self::Error> {
            ConsumerLocalNb::close(&mut self.0, f).await
        }

        async fn consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::local_nb::ConsumeFullSliceError<Self::Error>>
        where
            Self::Item: Clone,
        {
            ConsumerLocalNb::consume_full_slice(&mut self.0, buf).await
        }
    }
}

/// Implement `local_nb::Consumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_consumer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::local_nb::Consumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            $(#[$doc_item])*
            type Item = $t_item;
            $(#[$doc_final])*
            type Final = $t_final;
            $(#[$doc_error])*
            type Error = $t_error;

            invarianted_consumer_methods_local_nb!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::BufferedConsmer`.
macro_rules! invarianted_buffered_consumer_methods_local_nb {
    () => {
        async fn flush(&mut self) -> Result<(), Self::Error> {
            BufferedConsumerLocalNb::flush(&mut self.0).await
        }
    }
}

/// Implement `local_nb::BufferedConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_buffered_consumer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::local_nb::BufferedConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_buffered_consumer_methods_local_nb!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::BulkConsmer`.
macro_rules! invarianted_bulk_consumer_methods_local_nb {
    () => {
        async fn expose_slots<'b>(
            &'b mut self,
        ) -> Result<&'b mut [MaybeUninit<Self::Item>], Self::Error>
        where
            Self::Item: 'b,
        {
            BulkConsumerLocalNb::expose_slots(&mut self.0).await
        }

        async unsafe fn consume_slots(&mut self, amount: usize) -> Result<(), Self::Error> {
            BulkConsumerLocalNb::consume_slots(&mut self.0, amount).await
        }

        async fn bulk_consume(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<usize, Self::Error> {
            BulkConsumerLocalNb::bulk_consume(&mut self.0, buf).await
        }

        async fn bulk_consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::local_nb::ConsumeFullSliceError<Self::Error>> {
            BulkConsumerLocalNb::bulk_consume_full_slice(&mut self.0, buf).await
        }
    }
}

/// Implement `local_nb::BulkConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_bulk_consumer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::local_nb::BulkConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_bulk_consumer_methods_local_nb!();
        }
    }
}

/// Implement both `sync::Consumer` and `local_nb::Consumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_consumer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        invarianted_consumer_impl_consumer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $(#[$doc_item])? Item $t_item; $(#[$doc_final])? Final $t_final; $(#[$doc_error])? Error $t_error);
        invarianted_consumer_impl_consumer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $(#[$doc_item])? Item $t_item; $(#[$doc_final])? Final $t_final; $(#[$doc_error])? Error $t_error);
    }
}

/// Implement both `sync::BufferedConsumer` and `local_nb::BufferedConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_buffered_consumer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        invarianted_consumer_impl_buffered_consumer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
        invarianted_consumer_impl_buffered_consumer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
    }
}

/// Implement both `sync::BulkConsumer` and `local_nb::BulkConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_consumer_impl_bulk_consumer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        invarianted_consumer_impl_bulk_consumer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
        invarianted_consumer_impl_bulk_consumer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
    }
}

// And now for something completely differend.

/// Implement `local_nb::Consumer` on a type by forwarding to its implementation of `sync::Consumer`.
macro_rules! sync_consumer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::local_nb::Consumer
        for $outer
            $(< $( $lt ),+ >)? {
                type Item = <Self as crate::sync::Consumer>::Item;
                type Final = <Self as crate::sync::Consumer>::Final;
                type Error = <Self as crate::sync::Consumer>::Error;

                async fn consume(&mut self, item: Self::Item) -> Result<(), Self::Error> {
                    Consumer::consume(self, item)
                }

                async fn close(&mut self, f: Self::Final) -> Result<(), Self::Error> {
                    Consumer::close(self, f)
                }
            }
    }
}

/// Implement `local_nb::BufferedConsumer` on a type by forwarding to its implementation of `sync::BufferedConsumer`.
macro_rules! sync_buffered_consumer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            crate::local_nb::BufferedConsumer
        for $outer
            $(< $( $lt ),+ >)? {
                async fn flush(&mut self) -> Result<(), Self::Error> {
                    BufferedConsumer::flush(self)
                }
            }
    }
}

/// Implement `local_nb::BulkConsumer` on a type by forwarding to its implementation of `sync::NulkConsumer`.
macro_rules! sync_bulk_consumer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BulkConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            async fn expose_slots<'b>(
                &'b mut self,
            ) -> Result<&'b mut [MaybeUninit<Self::Item>], Self::Error>
            where
                Self::Item: 'b,
            {
                BulkConsumer::expose_slots(self)
            }

            async unsafe fn consume_slots(&mut self, amount: usize) -> Result<(), Self::Error> {
                BulkConsumer::consume_slots(self, amount)
            }
        }
    }
}
