//! Macros for quickly writing producers.
//!
//! More specifically, a family of macros for wrapper producers with an invariant wrapper and implementing various traits on the
//! resulting type by forwarding to the wrapper.
//!
//! Also, a family of macros to implement `local_nb::Producer` by referring to an implementation of `sync::local_nb::Producer`.
//!
//! See `common::producer::from_slice` for example usage of all these macros.

// Macro syntax for handling generic parameters from https://stackoverflow.com/a/61189128

/// Create an opaque type of name `outer` that wraps the producer `inner` with invariant checks.
macro_rules! invarianted_producer_outer_type {
    ($(#[$doc:meta])* $outer:ident $inner:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? ) => {
        $(#[$doc])*
        pub struct $outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?(ufotofu::common::producer::Invariant<$inner $(< $( $lt ),+ >)?>);
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::Producer`.
macro_rules! invarianted_producer_methods {
    () => {
        fn produce(&mut self) -> Result<Either<Self::Item, Self::Final>, Self::Error> {
            ufotofu::sync::Producer::produce(&mut self.0)
        }

        fn overwrite_full_slice<'b>(
            &mut self,
            buf: &'b mut [Self::Item],
        ) -> Result<(), ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>> {
            ufotofu::sync::Producer::overwrite_full_slice(&mut self.0, buf)
        }

        fn overwrite_full_slice_uninit<'b>(
            &mut self,
            buf: &'b mut [core::mem::MaybeUninit<Self::Item>],
        ) -> Result<
            &'b mut [Self::Item],
            ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>,
        > {
            ufotofu::sync::Producer::overwrite_full_slice_uninit(&mut self.0, buf)
        }
    };
}

/// Implement `sync::Producer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_producer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::sync::Producer
        for $outer
            $(< $( $lt ),+ >)?
        {
            $(#[$doc_item])*
            type Item = $t_item;
            $(#[$doc_final])*
            type Final = $t_final;
            $(#[$doc_error])*
            type Error = $t_error;

            invarianted_producer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::BufferedConsmer`.
macro_rules! invarianted_buffered_producer_methods {
    () => {
        fn slurp(&mut self) -> Result<(), Self::Error> {
            ufotofu::sync::BufferedProducer::slurp(&mut self.0)
        }
    };
}

/// Implement `sync::BufferedProducer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_buffered_producer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::sync::BufferedProducer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_buffered_producer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::BulkProducer`.
macro_rules! invarianted_bulk_producer_methods {
    () => {
        fn expose_items(&mut self) -> Result<Either<&[Self::Item], Self::Final>, Self::Error> {
            ufotofu::sync::BulkProducer::expose_items(&mut self.0)
        }

        fn consider_produced(&mut self, amount: usize) -> Result<(), Self::Error> {
            ufotofu::sync::BulkProducer::consider_produced(&mut self.0, amount)
        }

        fn bulk_produce(
            &mut self,
            buf: &mut [Self::Item],
        ) -> Result<Either<usize, Self::Final>, Self::Error> {
            ufotofu::sync::BulkProducer::bulk_produce(&mut self.0, buf)
        }

        fn bulk_overwrite_full_slice<'ihguiweg>(
            &mut self,
            buf: &'ihguiweg mut [Self::Item],
        ) -> Result<(), ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>> {
            ufotofu::sync::BulkProducer::bulk_overwrite_full_slice(&mut self.0, buf)
        }

        fn bulk_overwrite_full_slice_uninit<'ihguiweg>(
            &mut self,
            buf: &'ihguiweg mut [core::mem::MaybeUninit<Self::Item>],
        ) -> Result<
            &'ihguiweg mut [Self::Item],
            ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>,
        > {
            ufotofu::sync::BulkProducer::bulk_overwrite_full_slice_uninit(&mut self.0, buf)
        }
    };
}

/// Implement `sync::BulkProducer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_bulk_producer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::sync::BulkProducer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_bulk_producer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::Producer`.
macro_rules! invarianted_producer_methods_local_nb {
    () => {
        async fn produce(&mut self) -> Result<Either<Self::Item, Self::Final>, Self::Error> {
            ufotofu::local_nb::Producer::produce(&mut self.0).await
        }

        async fn overwrite_full_slice<'b>(
            &mut self,
            buf: &'b mut [Self::Item],
        ) -> Result<(), ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>> {
            ufotofu::local_nb::Producer::overwrite_full_slice(&mut self.0, buf).await
        }

        async fn overwrite_full_slice_uninit<'b>(
            &mut self,
            buf: &'b mut [core::mem::MaybeUninit<Self::Item>],
        ) -> Result<
            &'b mut [Self::Item],
            ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>,
        > {
            ufotofu::local_nb::Producer::overwrite_full_slice_uninit(&mut self.0, buf).await
        }
    };
}

/// Implement `local_nb::Producer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_producer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::Producer
        for $outer
            $(< $( $lt ),+ >)?
        {
            $(#[$doc_item])*
            type Item = $t_item;
            $(#[$doc_final])*
            type Final = $t_final;
            $(#[$doc_error])*
            type Error = $t_error;

            invarianted_producer_methods_local_nb!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::BufferedConsmer`.
macro_rules! invarianted_buffered_producer_methods_local_nb {
    () => {
        async fn slurp(&mut self) -> Result<(), Self::Error> {
            ufotofu::local_nb::BufferedProducer::slurp(&mut self.0).await
        }
    };
}

/// Implement `local_nb::BufferedProducer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_buffered_producer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BufferedProducer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_buffered_producer_methods_local_nb!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::BulkConsmer`.
macro_rules! invarianted_bulk_producer_methods_local_nb {
    () => {
        async fn expose_items<'kfhwkfwe>(
            &'kfhwkfwe mut self,
        ) -> Result<Either<&'kfhwkfwe [Self::Item], Self::Final>, Self::Error>
        where
            Self::Item: 'kfhwkfwe,
        {
            ufotofu::local_nb::BulkProducer::expose_items(&mut self.0).await
        }

        async fn consider_produced(&mut self, amount: usize) -> Result<(), Self::Error> {
            ufotofu::local_nb::BulkProducer::consider_produced(&mut self.0, amount).await
        }

        async fn bulk_produce(
            &mut self,
            buf: &mut [Self::Item],
        ) -> Result<Either<usize, Self::Final>, Self::Error> {
            ufotofu::local_nb::BulkProducer::bulk_produce(&mut self.0, buf).await
        }

        async fn bulk_produce_uninit(
            &mut self,
            buf: &mut [core::mem::MaybeUninit<Self::Item>],
        ) -> Result<Either<usize, Self::Final>, Self::Error> {
            ufotofu::local_nb::BulkProducer::bulk_produce_uninit(&mut self.0, buf).await
        }

        async fn bulk_overwrite_full_slice<'kfhwkfwe>(
            &mut self,
            buf: &'kfhwkfwe mut [Self::Item],
        ) -> Result<(), ufotofu::local_nb::OverwriteFullSliceError<Self::Final, Self::Error>> {
            ufotofu::local_nb::BulkProducer::bulk_overwrite_full_slice(&mut self.0, buf).await
        }

        async fn bulk_overwrite_full_slice_uninit<'kfhwkfwe>(
            &mut self,
            buf: &'kfhwkfwe mut [core::mem::MaybeUninit<Self::Item>],
        ) -> Result<
            &'kfhwkfwe mut [Self::Item],
            ufotofu::local_nb::OverwriteFullSliceError<Self::Final, Self::Error>,
        > {
            ufotofu::local_nb::BulkProducer::bulk_overwrite_full_slice_uninit(&mut self.0, buf)
                .await
        }
    };
}

/// Implement `local_nb::BulkProducer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_bulk_producer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BulkProducer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_bulk_producer_methods_local_nb!();
        }
    }
}

/// Implement both `sync::Producer` and `local_nb::Producer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_producer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        invarianted_impl_producer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $(#[$doc_item])? Item $t_item; $(#[$doc_final])? Final $t_final; $(#[$doc_error])? Error $t_error);
        invarianted_impl_producer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $(#[$doc_item])? Item $t_item; $(#[$doc_final])? Final $t_final; $(#[$doc_error])? Error $t_error);
    }
}

/// Implement both `sync::BufferedProducer` and `local_nb::BufferedProducer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_buffered_producer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        invarianted_impl_buffered_producer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
        invarianted_impl_buffered_producer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
    }
}

/// Implement both `sync::BulkProducer` and `local_nb::BulkProducer` for an opaque invariant wrapper type generated by the invarianted_producer_outer_type macro.
macro_rules! invarianted_impl_bulk_producer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        invarianted_impl_bulk_producer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
        invarianted_impl_bulk_producer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
    }
}

// And now for something completely different.

/// Implement `local_nb::Producer` on a type by forwarding to its implementation of `sync::Producer`.
macro_rules! sync_producer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::Producer
        for $outer
            $(< $( $lt ),+ >)? {
                type Item = <Self as ufotofu::sync::Producer>::Item;
                type Final = <Self as ufotofu::sync::Producer>::Final;
                type Error = <Self as ufotofu::sync::Producer>::Error;

                async fn produce(&mut self) -> Result<Either<Self::Item, Self::Final>, Self::Error> {
                    ufotofu::sync::Producer::produce(self)
                }

                async fn overwrite_full_slice<'b>(
                    &mut self,
                    buf: &'b mut [Self::Item],
                ) -> Result<(), ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>> {
                    ufotofu::sync::Producer::overwrite_full_slice(self, buf)
                }

                async fn overwrite_full_slice_uninit<'b>(
                    &mut self,
                    buf: &'b mut [core::mem::MaybeUninit<Self::Item>],
                ) -> Result<
                    &'b mut [Self::Item],
                    ufotofu::sync::OverwriteFullSliceError<Self::Final, Self::Error>,
                > {
                    ufotofu::sync::Producer::overwrite_full_slice_uninit(self, buf)
                }
            }
    }
}

/// Implement `local_nb::BufferedProducer` on a type by forwarding to its implementation of `sync::BufferedProducer`.
macro_rules! sync_buffered_producer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BufferedProducer
        for $outer
            $(< $( $lt ),+ >)? {
                async fn slurp(&mut self) -> Result<(), Self::Error> {
                    ufotofu::sync::BufferedProducer::slurp(self)
                }
            }
    }
}

/// Implement `local_nb::BulkProducer` on a type by forwarding to its implementation of `sync::NulkProducer`.
macro_rules! sync_bulk_producer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BulkProducer
        for $outer
            $(< $( $lt ),+ >)?
        {
            async fn expose_items<'kfhwkfwe>(
                &'kfhwkfwe mut self,
            ) -> Result<Either<&'kfhwkfwe [Self::Item], Self::Final>, Self::Error>
            where
                Self::Item: 'kfhwkfwe,
            {
                ufotofu::sync::BulkProducer::expose_items(self)
            }

            async fn consider_produced(&mut self, amount: usize) -> Result<(), Self::Error> {
                ufotofu::sync::BulkProducer::consider_produced(self, amount)
            }

            async fn bulk_produce(
                &mut self,
                buf: &mut [Self::Item],
            ) -> Result<Either<usize, Self::Final>, Self::Error> {
                ufotofu::sync::BulkProducer::bulk_produce(self, buf)
            }

            async fn bulk_produce_uninit(
                &mut self,
                buf: &mut [core::mem::MaybeUninit<Self::Item>],
            ) -> Result<Either<usize, Self::Final>, Self::Error> {
                ufotofu::sync::BulkProducer::bulk_produce_uninit(self, buf)
            }

            async fn bulk_overwrite_full_slice<'kfhwkfwe>(
                &mut self,
                buf: &'kfhwkfwe mut [Self::Item],
            ) -> Result<(), ufotofu::local_nb::OverwriteFullSliceError<Self::Final, Self::Error>> {
                ufotofu::sync::BulkProducer::bulk_overwrite_full_slice(self, buf)
            }

            async fn bulk_overwrite_full_slice_uninit<'kfhwkfwe>(
                &mut self,
                buf: &'kfhwkfwe mut [core::mem::MaybeUninit<Self::Item>],
            ) -> Result<
                &'kfhwkfwe mut [Self::Item],
                ufotofu::local_nb::OverwriteFullSliceError<Self::Final, Self::Error>,
            > {
                ufotofu::sync::BulkProducer::bulk_overwrite_full_slice_uninit(self, buf)
            }
        }
    }
}
